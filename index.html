<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Fundraiser Leaderboard</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style>
      :root { --bg:#f6f7f8; --card:#fff; --border:#e5e7eb; --text:#111; --muted:#6b7280; --err:#b91c1c; }
      body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; margin:0; background:var(--bg); color:var(--text); }
      .wrap { max-width: 1100px; margin: 0 auto; padding: 24px; }
      .card { background:var(--card); border:1px solid var(--border); border-radius:16px; box-shadow: 0 1px 4px rgba(0,0,0,0.04); }
      .row { display:flex; gap:12px; flex-wrap:wrap; align-items:center; }
      .btn { padding:8px 12px; border:1px solid var(--border); border-radius:12px; background:#fff; cursor:pointer; font-size:14px; }
      .btn[aria-pressed="true"] { background:#111; color:#fff; border-color:#111; }
      .muted { color: var(--muted); font-size:12px; }
      .errbox { display:none; background:#fee2e2; border:1px solid #fecaca; color:var(--err); padding:8px 12px; border-radius:10px; margin: 12px 0; font-size:13px; }
      code { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; }
      .chart { height: 460px; }
      .svg-wrap { width: 100%; height: 100%; }
      svg { width: 100%; height: 100%; display:block; }
      /* allow CSS transforms on SVG groups to look crisp */
      g.bar { will-change: transform; }
    </style>

    <!-- React + ReactDOM + Babel (no build step) -->
    <script src="https://unpkg.com/react@18/umd/react.production.min.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js" crossorigin></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  </head>
  <body>
    <div class="wrap">
      <div id="error" class="errbox"></div>
      <div id="root"></div>
    </div>

    <script type="text/babel" data-presets="env,react">
      // on-page error display so we never get a silent blank page
      // Animation timings (ms)
const RISE_MS = 2400;                 // was 1200 → now 2x slower
const PAUSE_BEFORE_REORDER_MS = 1200; // was 800 → a bit longer pause
const REORDER_MS = 1500;              // was 1200 → ~25% longer slide
(function attachErrorBox(){
        const box = document.getElementById('error');
        function show(msg){
          box.style.display = 'block';
          box.textContent = 'Error: ' + msg;
        }
        window.addEventListener('error', e => show(e.message));
        window.addEventListener('unhandledrejection', e => show(e.reason && e.reason.message ? e.reason.message : String(e.reason)));
      })();

      const { useEffect, useMemo, useRef, useState } = React;

      const METRICS = [
        { key: "totalGifts", label: "Total Gifts", fmt: v => "$" + Number(v).toLocaleString() },
        { key: "percentGivers", label: "% of Givers", fmt: v => Number(v).toFixed(1) + "%" },
        { key: "percentRecurring", label: "% Recurring (people)", fmt: v => Number(v).toFixed(1) + "%" },
        { key: "percentRecurringByGifts", label: "% Recurring (gifts)", fmt: v => Number(v).toFixed(1) + "%" },
      ];

      const COLORS = ["#f97316","#38bdf8","#34d399","#a78bfa","#fde047","#60a5fa","#22d3ee",
                      "#f59e0b","#84cc16","#14b8a6","#ec4899","#6366f1","#eab308","#10b981","#3b82f6"];

      // y-axis ticks helper
      function niceTicks(max, count = 5) {
        if (max <= 0 || !isFinite(max)) return [0, 1];
        const rough = max / count;
        const pow10 = Math.pow(10, Math.floor(Math.log10(rough)));
        let nice = pow10;
        if (rough / pow10 >= 5) nice = 5 * pow10;
        else if (rough / pow10 >= 2) nice = 2 * pow10;
        const top = Math.ceil(max / nice) * nice;
        const out = [];
        for (let v = 0; v <= top + 1e-9; v += nice) out.push(v);
        return out;
      }

      // easing
      const easeOutCubic = t => 1 - Math.pow(1 - t, 3);

      function App(){
        const [metric, setMetric] = useState("totalGifts");
        const [rows, setRows] = useState([]);
        const [loading, setLoading] = useState(true);
        const [error, setError] = useState(null);
        const [lastUpdated, setLastUpdated] = useState(null);

        // animation state
        const [animated, setAnimated] = useState([]); // [{year, value}]
        const [sorted, setSorted] = useState(false);
        const [reordering, setReordering] = useState(false);

        // layout
        const holderRef = useRef(null);
        const [width, setWidth] = useState(980);
        useEffect(() => {
          const set = () => setWidth(holderRef.current ? holderRef.current.clientWidth : 980);
          set();
          window.addEventListener('resize', set);
          return () => window.removeEventListener('resize', set);
        }, []);

        // fetch once
        useEffect(() => {
          (async () => {
            try {
              setLoading(true); setError(null);
              const r = await fetch("/.netlify/functions/leaderboard", { cache: "no-store" });
              const json = await r.json();
              if(!r.ok) throw new Error(json?.error || "Failed to load");
              const arr = Array.isArray(json.rows) ? json.rows : [];
              setRows(arr);
              setLastUpdated(new Date());
            } catch(e) {
              setError(String(e.message || e));
            } finally {
              setLoading(false);
            }
          })();
        }, []);

        // prepare data & targets
        const targets = useMemo(() => rows.map(r => ({ year: r.year, value: Number(r[metric]) || 0 })), [rows, metric]);

        // max & ticks
        const yMax = useMemo(() => {
          const max = targets.reduce((m, d) => Math.max(m, d.value || 0), 0);
          if (metric === "totalGifts") {
            const step = 1000;
            return Math.max(step, Math.ceil(max/step)*step);
          }
          return 100;
        }, [targets, metric]);
        const ticks = useMemo(() => metric === "totalGifts" ? niceTicks(yMax, 5) : [0,20,40,60,80,100], [yMax, metric]);
        const fmtTick = v => (metric === "totalGifts" ? "$" + Number(v).toLocaleString() : v + "%");
        const metricObj = METRICS.find(m => m.key === metric);

        // play rise animation whenever metric or rows change
        const rafRef = useRef(null);
        const FLIP_prevX = useRef(new Map());
        const barRefs = useRef(new Map());

        function playRise() {
          if (rafRef.current) cancelAnimationFrame(rafRef.current);
          setSorted(false);
          setReordering(false);
          // start at zeros
          setAnimated(targets.map(t => ({ year: t.year, value: 0 })));
          const start = performance.now();
          const duration = RISE_MS;

          function step(now) {
            const t = Math.min(1, (now - start) / duration);
            const eased = easeOutCubic(t);
            const next = targets.map(tgt => ({ year: tgt.year, value: tgt.value * eased }));
            setAnimated(next);
            if (t < 1) {
              rafRef.current = requestAnimationFrame(step);
            } else {
              // hold briefly, then reorder with FLIP
              setTimeout(() => startReorder(), PAUSE_BEFORE_REORDER_MS));
            }
          }
          rafRef.current = requestAnimationFrame(step);
        }

        // run on data/metric change
        useEffect(() => {
          if (rows.length) playRise();
          // eslint-disable-next-line react-hooks/exhaustive-deps
        }, [metric, rows.length]);

        // compute display data from animated values
        const disp = useMemo(() => {
          const aMap = new Map(animated.map(a => [a.year, a.value]));
          const base = rows.map(r => ({
            ...r,
            value: aMap.get(r.year) || 0
          }));
          if (sorted) return [...base].sort((x,y) => y.value - x.value);
          return [...base].sort((x,y) => x.year - y.year);
        }, [rows, animated, sorted]);

        // layout dims
        const H = 420;
        const M = { top: 20, right: 20, bottom: 70, left: 70 };
        const innerW = Math.max(320, width) - M.left - M.right;
        const innerH = H - M.top - M.bottom;
        const n = disp.length || 1;
        const band = innerW / n;
        const barPad = Math.min(12, band * 0.2);
        const barW = Math.max(2, band - barPad);
        const xPos = (i) => M.left + i * band + (band - barW) / 2;
        const yPos = (v) => {
          const maxV = (metric === "totalGifts") ? yMax : 100;
          const t = Math.min(1, Math.max(0, (v || 0) / (maxV || 1)));
          return M.top + (1 - t) * innerH;
        };

        // FLIP reorder: capture old X, then sort, then animate to new X
        function startReorder() {
          // capture current centers
          const prev = new Map();
          disp.forEach((d, i) => prev.set(d.year, xPos(i) + barW/2));
          FLIP_prevX.current = prev;

          setSorted(true);
          setReordering(true);
        }

        // after sorted render, do the flip animation
        useEffect(() => {
          if (!reordering) return;
          // allow DOM paint
          requestAnimationFrame(() => {
            // position jump to old place, then animate to 0
            disp.forEach((d, i) => {
              const node = barRefs.current.get(d.year);
              if (!node) return;
              const prevX = FLIP_prevX.current.get(d.year) || 0;
              const newX = xPos(i) + barW/2;
              const delta = prevX - newX;

              node.style.transition = "none";
              node.style.transform = `translate(${delta}px, 0px)`;
            });

            // force reflow
            void document.body.offsetHeight;

            disp.forEach((d) => {
              const node = barRefs.current.get(d.year);
              if (!node) return;
              node.style.transition = "transform ${REORDER_MS}ms cubic-bezier(0.22,1,0.36,1)";
              node.style.transform = "translate(0px, 0px)";
            });

            // cleanup flag
            setTimeout(() => setReordering(false), REORDER_MS + 100);
          });
          // eslint-disable-next-line react-hooks/exhaustive-deps
        }, [reordering, width]); // width matters because x positions scale with container

        const topText = useMemo(() => {
          const tops = [...rows].sort((a,b)=> (b.totalGifts||0)-(a.totalGifts||0)).slice(0,3)
            .filter(d => (d.totalGifts||0) > 0);
          return tops.length ? tops.map(d => `${d.year}: $${(d.totalGifts||0).toLocaleString()}`).join(" · ") : "No totals yet";
        }, [rows]);

        return (
          <div>
            <header className="card" style={{padding:"16px 16px 8px"}}>
              <h1 style={{margin:"0 0 6px"}}>FL — Live Leaderboard</h1>
              <div className="muted">Loads from Google Sheets (via Netlify Function)</div>
              <div className="muted" style={{marginTop:6}}>
                {loading ? "Loading…" : (error ? <span style={{color:"#b91c1c"}}>Error: {error}</span> : <>Last updated: {lastUpdated && lastUpdated.toLocaleTimeString()}</>)}
              </div>
              <div style={{height:8}}/>
              <div className="row" role="group" aria-label="Choose metric">
                {METRICS.map(m => (
                  <button key={m.key} className="btn"
                          aria-pressed={metric===m.key}
                          onClick={()=>setMetric(m.key)}>{m.label}</button>
                ))}
              </div>
              <div className="muted" style={{marginTop:8}}>Top totals: {topText}</div>
            </header>

            <section className="card chart" style={{marginTop:16, padding:12}}>
              <div ref={holderRef} className="svg-wrap">
                <svg viewBox={`0 0 ${Math.max(320,width)} ${H}`} preserveAspectRatio="xMidYMid meet" role="img" aria-label="Leaderboard bar chart">
                  {/* Y grid + ticks */}
                  {ticks.map((t, i) => {
                    const y = yPos(t);
                    return (
                      <g key={`tick-${i}`}>
                        <line x1={M.left} y1={y} x2={Math.max(320,width) - M.right} y2={y} stroke="#eee" />
                        <text x={M.left - 10} y={y + 4} textAnchor="end" fontSize="12" fill="#111">
                          {fmtTick(t)}
                        </text>
                      </g>
                    );
                  })}
                  {/* X axis baseline */}
                  <line x1={M.left} y1={H - M.bottom} x2={Math.max(320,width) - M.right} y2={H - M.bottom} stroke="#ddd" />

                  {/* Bars + labels in groups (so FLIP can move both) */}
                  {disp.map((d, i) => {
                    const x = xPos(i);
                    const y = yPos(d.value);
                    const h = (H - M.bottom) - y;
                    const color = COLORS[i % COLORS.length];
                    const cx = x + barW/2;

                    return (
                      <g key={d.year} className="bar" ref={el => { if (el) barRefs.current.set(d.year, el); }}>
                        <rect x={x} y={y} width={barW} height={Math.max(0, h)} fill={color} rx="8" ry="8">
                          <title>{`Class of ${d.year}\n${metricObj.label}: ${metricObj.fmt(d.value)}`}</title>
                        </rect>
                        {/* value label on top of bar (optional) */}
                        <text x={cx} y={y - 6} textAnchor="middle" fontSize="11" fill="#111">
                          {metricObj.fmt(d.value)}
                        </text>
                        {/* rotated year label */}
                        <text x={cx} y={H - M.bottom + 14} fontSize="10" fill="#111"
                              textAnchor="end" transform={`rotate(-45 ${cx} ${H - M.bottom + 14})`}>
                          {d.year}
                        </text>
                      </g>
                    );
                  })}
                </svg>
              </div>
            </section>

            <footer style={{marginTop:12}} className="muted">
              Data endpoint: <code>/.netlify/functions/leaderboard</code>
            </footer>
          </div>
        );
      }

      const root = ReactDOM.createRoot(document.getElementById("root"));
      root.render(<App />);
    </script>
  </body>
</html>
