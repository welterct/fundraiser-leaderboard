<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Fundraiser Leaderboard</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style>
      :root { --bg:#f6f7f8; --card:#fff; --border:#e5e7eb; --text:#111; --muted:#6b7280; --err:#b91c1c; }
      body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; margin:0; background:var(--bg); color:var(--text); }
      .wrap { max-width: 1100px; margin: 0 auto; padding: 24px; }
      .card { background:var(--card); border:1px solid var(--border); border-radius:16px; box-shadow: 0 1px 4px rgba(0,0,0,0.04); }
      .row { display:flex; gap:12px; flex-wrap:wrap; align-items:center; }
      .btn { padding:8px 12px; border:1px solid var(--border); border-radius:12px; background:#fff; cursor:pointer; font-size:14px; }
      .btn[aria-pressed="true"] { background:#111; color:#fff; border-color:#111; }
      .muted { color: var(--muted); font-size:12px; }
      .errbox { display:none; background:#fee2e2; border:1px solid #fecaca; color:var(--err); padding:8px 12px; border-radius:10px; margin: 12px 0; font-size:13px; }
      code { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; }
      svg { width: 100%; height: 100%; }
    </style>

    <!-- React + ReactDOM (UMD) + Babel for JSX (no build step needed) -->
    <script src="https://unpkg.com/react@18/umd/react.production.min.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js" crossorigin></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  </head>
  <body>
    <div class="wrap">
      <div id="error" class="errbox"></div>
      <div id="root"></div>
    </div>

    <!-- App (pure SVG chart) -->
    <script type="text/babel" data-presets="env,react">
      // Show any runtime errors on the page (not just in the console)
      (function attachErrorBox(){
        const box = document.getElementById('error');
        function show(msg){
          box.style.display = 'block';
          box.textContent = 'Error: ' + msg;
        }
        window.addEventListener('error', e => show(e.message));
        window.addEventListener('unhandledrejection', e => show(e.reason && e.reason.message ? e.reason.message : String(e.reason)));
      })();

      const { useEffect, useMemo, useState } = React;

      const METRICS = [
        { key: "totalGifts", label: "Total Gifts", fmt: v => "$" + Number(v).toLocaleString() },
        { key: "percentGivers", label: "% of Givers", fmt: v => Number(v).toFixed(1) + "%" },
        { key: "percentRecurring", label: "% Recurring (people)", fmt: v => Number(v).toFixed(1) + "%" },
        { key: "percentRecurringByGifts", label: "% Recurring (gifts)", fmt: v => Number(v).toFixed(1) + "%" },
      ];

      const COLORS = ["#f97316","#38bdf8","#34d399","#a78bfa","#fde047","#60a5fa","#22d3ee",
                      "#f59e0b","#84cc16","#14b8a6","#ec4899","#6366f1","#eab308","#10b981","#3b82f6"];

      // Nice tick generator for Y axis (0..max with ~5 ticks)
      function niceTicks(max, count = 5) {
        if (max <= 0 || !isFinite(max)) return [0, 1];
        const rough = max / count;
        const pow10 = Math.pow(10, Math.floor(Math.log10(rough)));
        let nice = pow10;
        if (rough / pow10 >= 5) nice = 5 * pow10;
        else if (rough / pow10 >= 2) nice = 2 * pow10;
        const top = Math.ceil(max / nice) * nice;
        const out = [];
        for (let v = 0; v <= top + 1e-9; v += nice) out.push(v);
        return out;
      }

      function App(){
        const [metric, setMetric] = useState("totalGifts");
        const [rows, setRows] = useState([]);
        const [loading, setLoading] = useState(true);
        const [error, setError] = useState(null);
        const [sortByValue, setSortByValue] = useState(false);
        const [lastUpdated, setLastUpdated] = useState(null);

        useEffect(() => {
          (async () => {
            try {
              setLoading(true);
              setError(null);
              const r = await fetch("/.netlify/functions/leaderboard", { cache: "no-store" });
              const json = await r.json();
              if(!r.ok) throw new Error(json?.error || "Failed to load");
              setRows(Array.isArray(json.rows) ? json.rows : []);
              setLastUpdated(new Date());
            } catch(e) {
              setError(String(e.message || e));
            } finally {
              setLoading(false);
            }
          })();
        }, []);

        const data = useMemo(() => {
          const arr = rows.map(r => ({ ...r, value: Number(r[metric]) || 0 }));
          if (sortByValue) return [...arr].sort((a,b) => b.value - a.value);
          return [...arr].sort((a,b) => a.year - b.year);
        }, [rows, metric, sortByValue]);

        const yMax = useMemo(() => {
          const max = data.reduce((m, d) => Math.max(m, d.value || 0), 0);
          if (metric === "totalGifts") {
            const step = 1000;
            return Math.max(step, Math.ceil(max/step)*step);
          }
          return Math.max(100, Math.ceil(max));
        }, [data, metric]);

        const ticks = useMemo(() => {
          if (metric === "t
