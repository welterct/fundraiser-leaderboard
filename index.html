<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Fundraiser Leaderboard</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style>
      :root { --bg:#f6f7f8; --card:#fff; --border:#e5e7eb; --text:#111; --muted:#6b7280; --err:#b91c1c; }
      body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; margin:0; background:var(--bg); color:var(--text); }
      .wrap { max-width: 1100px; margin: 0 auto; padding: 24px; }
      .card { background:var(--card); border:1px solid var(--border); border-radius:16px; box-shadow: 0 1px 4px rgba(0,0,0,0.04); }
      .row { display:flex; gap:12px; flex-wrap:wrap; align-items:center; }
      .btn { padding:8px 12px; border:1px solid var(--border); border-radius:12px; background:#fff; cursor:pointer; font-size:14px; }
      .btn[aria-pressed="true"] { background:#111; color:#fff; border-color:#111; }
      .muted { color: var(--muted); font-size:12px; }
      .errbox { display:none; background:#fee2e2; border:1px solid #fecaca; color:var(--err); padding:8px 12px; border-radius:10px; margin: 12px 0; font-size:13px; }
      code { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; }
      svg { width: 100%; height: 100%; }
    </style>

    <!-- React + ReactDOM (UMD) + Babel for JSX (no build step needed) -->
    <script src="https://unpkg.com/react@18/umd/react.production.min.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js" crossorigin></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  </head>
  <body>
    <div class="wrap">
      <div id="error" class="errbox"></div>
      <div id="root"></div>
    </div>

    <!-- App (pure SVG chart) -->
    <script type="text/babel" data-presets="env,react">
      // Show any runtime errors on the page (not just in the console)
      (function attachErrorBox(){
        const box = document.getElementById('error');
        function show(msg){
          box.style.display = 'block';
          box.textContent = 'Error: ' + msg;
        }
        window.addEventListener('error', e => show(e.message));
        window.addEventListener('unhandledrejection', e => show(e.reason && e.reason.message ? e.reason.message : String(e.reason)));
      })();

      const { useEffect, useMemo, useState } = React;

      const METRICS = [
        { key: "totalGifts", label: "Total Gifts", fmt: v => "$" + Number(v).toLocaleString() },
        { key: "percentGivers", label: "% of Givers", fmt: v => Number(v).toFixed(1) + "%" },
        { key: "percentRecurring", label: "% Recurring (people)", fmt: v => Number(v).toFixed(1) + "%" },
        { key: "percentRecurringByGifts", label: "% Recurring (gifts)", fmt: v => Number(v).toFixed(1) + "%" },
      ];

      const COLORS = ["#f97316","#38bdf8","#34d399","#a78bfa","#fde047","#60a5fa","#22d3ee",
                      "#f59e0b","#84cc16","#14b8a6","#ec4899","#6366f1","#eab308","#10b981","#3b82f6"];

      // Nice tick generator for Y axis (0..max with ~5 ticks)
      function niceTicks(max, count = 5) {
        if (max <= 0 || !isFinite(max)) return [0, 1];
        const rough = max / count;
        const pow10 = Math.pow(10, Math.floor(Math.log10(rough)));
        let nice = pow10;
        if (rough / pow10 >= 5) nice = 5 * pow10;
        else if (rough / pow10 >= 2) nice = 2 * pow10;
        const top = Math.ceil(max / nice) * nice;
        const out = [];
        for (let v = 0; v <= top + 1e-9; v += nice) out.push(v);
        return out;
      }

      function App(){
        const [metric, setMetric] = useState("totalGifts");
        const [rows, setRows] = useState([]);
        const [loading, setLoading] = useState(true);
        const [error, setError] = useState(null);
        const [sortByValue, setSortByValue] = useState(false);
        const [lastUpdated, setLastUpdated] = useState(null);

        useEffect(() => {
          (async () => {
            try {
              setLoading(true);
              setError(null);
              const r = await fetch("/.netlify/functions/leaderboard", { cache: "no-store" });
              const json = await r.json();
              if(!r.ok) throw new Error(json?.error || "Failed to load");
              setRows(Array.isArray(json.rows) ? json.rows : []);
              setLastUpdated(new Date());
            } catch(e) {
              setError(String(e.message || e));
            } finally {
              setLoading(false);
            }
          })();
        }, []);

        const data = useMemo(() => {
          const arr = rows.map(r => ({ ...r, value: Number(r[metric]) || 0 }));
          if (sortByValue) return [...arr].sort((a,b) => b.value - a.value);
          return [...arr].sort((a,b) => a.year - b.year);
        }, [rows, metric, sortByValue]);

        const yMax = useMemo(() => {
          const max = data.reduce((m, d) => Math.max(m, d.value || 0), 0);
          if (metric === "totalGifts") {
            const step = 1000;
            return Math.max(step, Math.ceil(max/step)*step);
          }
          return 100; // percentage metrics
        }, [data, metric]);

        const ticks = useMemo(() => {
          if (metric === "totalGifts") return niceTicks(yMax, 5);
          return [0, 20, 40, 60, 80, 100];
        }, [yMax, metric]);

        const fmtTick = v => (metric === "totalGifts" ? "$" + Number(v).toLocaleString() : v + "%");
        const metricObj = METRICS.find(m => m.key === metric);

        const topText = useMemo(() => {
          const tops = [...rows].sort((a,b)=> (b.totalGifts||0)-(a.totalGifts||0)).slice(0,3)
            .filter(d => (d.totalGifts||0) > 0);
          return tops.length ? tops.map(d => `${d.year}: $${(d.totalGifts||0).toLocaleString()}`).join(" · ") : "No totals yet";
        }, [rows]);

        // Chart layout
        const W = 980, H = 420;
        const M = { top: 20, right: 20, bottom: 70, left: 70 };
        const innerW = W - M.left - M.right;
        const innerH = H - M.top - M.bottom;

        // Scales
        const n = data.length || 1;
        const band = innerW / n;
        const barPad = Math.min(12, band * 0.2);
        const barW = Math.max(2, band - barPad);
        const xPos = (i) => M.left + i * band + (band - barW) / 2;
        const yPos = (v) => {
          const maxV = (metric === "totalGifts") ? yMax : 100;
          const t = Math.min(1, Math.max(0, v / (maxV || 1)));
          return M.top + (1 - t) * innerH;
        };

        return (
          <div>
            <header className="card" style={{padding:"16px 16px 8px"}}>
              <h1 style={{margin:"0 0 6px"}}>FL — Live Leaderboard</h1>
              <div className="muted">Loads from Google Sheets (via Netlify Function)</div>
              <div className="muted" style={{marginTop:6}}>
                {loading ? "Loading…" : (error ? <span style={{color:"#b91c1c"}}>Error: {error}</span> : <>Last updated: {lastUpdated && lastUpdated.toLocaleTimeString()}</>)}
              </div>
              <div style={{height:8}}/>
              <div className="row">
                {METRICS.map(m => (
                  <button key={m.key} className="btn"
                          aria-pressed={metric===m.key}
                          onClick={()=>setMetric(m.key)}>{m.label}</button>
                ))}
                <label className="muted" style={{display:"inline-flex", gap:8, alignItems:"center", marginLeft:8}}>
                  <input type="checkbox" checked={sortByValue} onChange={e=>setSortByValue(e.target.checked)} />
                  Sort by value (desc)
                </label>
              </div>
              <div className="muted" style={{marginTop:8}}>Top totals: {topText}</div>
            </header>

            <section className="card" style={{height:"460px", marginTop:16, padding:12}}>
              <div style={{width:"100%", height:"100%"}}>
                <svg viewBox={`0 0 ${W} ${H}`} preserveAspectRatio="xMidYMid meet" role="img" aria-label="Leaderboard bar chart">
                  {/* Y grid lines + ticks */}
                  {ticks.map((t, i) => {
                    const y = yPos(t);
                    return (
                      <g key={`tick-${i}`}>
                        <line x1={M.left} y1={y} x2={W - M.right} y2={y} stroke="#eee" />
                        <text x={M.left - 10} y={y + 4} textAnchor="end" fontSize="12" fill="#111">
                          {fmtTick(t)}
                        </text>
                      </g>
                    );
                  })}

                  {/* X axis baseline */}
                  <line x1={M.left} y1={H - M.bottom} x2={W - M.right} y2={H - M.bottom} stroke="#ddd" />

                  {/* Bars + labels */}
                  {data.map((d, i) => {
                    const x = xPos(i);
                    const y = yPos(d.value);
                    const h = (H - M.bottom) - y;
                    const color = COLORS[i % COLORS.length];
                    const cx = x + barW / 2;

                    return (
                      <g key={d.year}>
                        <rect
                          x={x} y={y} width={barW} height={Math.max(0, h)} fill={color}
                        >
                          <title>{`Class of ${d.year}\n${metricObj.label}: ${metricObj.fmt(d.value)}`}</title>
                        </rect>
                        <text
                          x={cx}
                          y={H - M.bottom + 14}
                          fontSize="10"
                          fill="#111"
                          textAnchor="end"
                          transform={`rotate(-45 ${cx} ${H - M.bottom + 14})`}
                        >
                          {d.year}
                        </text>
                      </g>
                    );
                  })}
                </svg>
              </div>
            </section>

            <footer style={{marginTop:12}} className="muted">
              Data endpoint: <code>/.netlify/functions/leaderboard</code>
            </footer>
          </div>
        );
      }

      const root = ReactDOM.createRoot(document.getElementById("root"));
      root.render(<App />);
    </script>
  </body>
</html>
